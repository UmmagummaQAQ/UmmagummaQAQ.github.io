<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MVC是什么</title>
    <link href="/2022/04/12/MVC%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/04/12/MVC%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul><li><p>MVC（Model-View-Controller）模式是软件工程中的是一种架构设计模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。MVC这一理念来源于后端的框架构建思想，是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到同一个部件里面，在改进和个性化定制界面及用户交互的同时，无需再重新编写业务逻辑。</p></li><li><p>Model-数据模型：负责操作所有数据，用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Model层</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Model</span> = &#123;<br>    <span class="hljs-attr">data</span>:&#123; &#125;; <span class="hljs-comment">// 需要用到的数据</span><br>    <span class="hljs-attr">create</span>:&#123; &#125;; <span class="hljs-comment">// 增数据</span><br>    <span class="hljs-attr">delete</span>:&#123; &#125;; <span class="hljs-comment">// 删数据</span><br>    <span class="hljs-attr">update</span>:&#123; &#125;; <span class="hljs-comment">// 更新数据</span><br>    <span class="hljs-attr">get</span>:&#123;&#125;; <span class="hljs-comment">// 获取数据</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>View-视图：负责所有UI界面的布局和显示，用于处理控制器里的HTML资料并且将它们插入DOM中，能够实现数据有目的的显示以及访问它监视的数据模型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// View层</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">View</span> = &#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">html</span>:<span class="hljs-string">`......`</span> <span class="hljs-comment">// 视图模板</span><br>    <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>)&#123; &#125;, <span class="hljs-comment">// 初始化页面</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123; &#125; <span class="hljs-comment">// 刷新页面</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Controller-控制器：负责连接视图和模型，用于处理业务逻辑操作&amp;处理事件并做出响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Controller层</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Controller</span> = &#123;<br>    <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>        v.<span class="hljs-title function_">init</span>() <span class="hljs-comment">// 初始化View </span><br>        v.<span class="hljs-title function_">render</span>() <span class="hljs-comment">// 第一次渲染页面 </span><br>        c.<span class="hljs-title function_">autoBindEvents</span>() <span class="hljs-comment">// 自动的事件绑定 </span><br>        eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;m:update&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            v.<span class="hljs-title function_">render</span>()<br>        &#125;  <span class="hljs-comment">// 当EventsBus触发&#x27;m:update&#x27;时，View刷新 </span><br>    &#125;<br>    <span class="hljs-attr">events</span>: &#123; &#125;, <span class="hljs-comment">// 事件以哈希表的方式记录存储</span><br>    <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>        data = <span class="hljs-comment">// 改变后的新数据</span><br>        m.<span class="hljs-title function_">update</span>(data)<br>    &#125;<br>    <span class="hljs-title function_">autoBindEvents</span>(<span class="hljs-params"></span>) &#123; &#125;; <span class="hljs-comment">// 自动绑定事件</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><ul><li><p>EventBus即事件总线，可以简化组件之间的监听和通信。当 Model 模块中的数据更新，触发了 EventBus 上的某个事件，而 Controller 恰好在监听这个事件，na那么这个事件触发时，Controller 就知道 Model 中的数据发生了更新了，从而做出相应反应。</p></li><li><p>Eventbus的API</p><ul><li><p><code>EventBus.on()</code> 监听事件：当 <code>m:updated</code> 触发时，执行一些内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">on</span>(eventName,callback) <span class="hljs-comment">// 参数1-事件名，参数2-事件函数</span><br><span class="hljs-keyword">const</span> eventList = &#123;&#125;;<br><span class="hljs-title class_">EventBus</span>.<span class="hljs-property">on</span> = <span class="hljs-function">(<span class="hljs-params">eventName,callback</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(!eventList[eventName])&#123;<br>        eventList[eventName] = []<br>    &#125; <br>    eventList[eventName].<span class="hljs-title function_">push</span>(callback) <br>    <span class="hljs-comment">// 判断事件名存在与否，若不存在则创建一个key值为事件名</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>EventBus.trigger()</code> 触发事件：当一个事件执行，eventBus 触发 <code>m:updated</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">trigger</span>(eventName,[params]) <span class="hljs-comment">// 参数1-事件名称 参数2-[需要传递的参数]</span><br><span class="hljs-keyword">const</span> eventList = &#123;&#125;;<br><span class="hljs-title class_">EventBus</span>.<span class="hljs-property">trigger</span> = <span class="hljs-function">(<span class="hljs-params">eventName,params</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(eventList[eventName])&#123;<br>         <span class="hljs-keyword">let</span> arr = eventList[eventName];<br>         arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>)=&gt;</span>&#123;<br>             <span class="hljs-title function_">cb</span>(params)<br>         &#125;)<br>    &#125; <br>    <span class="hljs-comment">// 判断当前事件的名称是否存在，如果存在则遍历数组，得到所有的函数，并执行，然后将params当做实参传递到函数中去</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>EventBus.off()</code> 解绑事件：取消监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">off</span>(eventName,[callback]) <span class="hljs-comment">// 参数1-事件名称，参数2-[事件函数]</span><br><span class="hljs-keyword">const</span> eventList = &#123;&#125;;<br><span class="hljs-title class_">EventBus</span>.<span class="hljs-property">off</span> = <span class="hljs-function">(<span class="hljs-params">eventName,callback</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(eventList[eventName])&#123;<br>          <span class="hljs-keyword">if</span>(callback)&#123;<br>                 <span class="hljs-keyword">let</span> index = eventList[eventName].<span class="hljs-title function_">indexOf</span>(callback);<br>                 eventList[eventName].<span class="hljs-title function_">splice</span>(index,<span class="hljs-number">1</span>)<br>           &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>           eventList[eventName].<span class="hljs-property">length</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果不存在则将整个数组清空</span><br>    &#125;<br>    <span class="hljs-comment">//判断当前事件名称是否存在，如果存在继续判断第二个参数是否存在，如果存在则找到相对应的下标，然后将函数在数组中移除</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h4><ul><li><p>一种编程模式，从表里面查找信息而不使用逻辑语句(if 和case)。凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。</p></li><li><p>使用方式：</p><ul><li>直接访问：将数据作为键值直接访问表</li><li>索引访问：先用一个基本数据类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你需要的主数据。</li><li>当表的数据与键值不一致时，可以：（1）复制表的数据使其与键值一一对应，变成直接访问；（2）创建一个索引，与表数据对应，查询时将键值转换成索引，变成索引访问。</li></ul></li><li><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置日期</span><br><span class="hljs-keyword">const</span> day = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>()<br><span class="hljs-keyword">let</span> day_zh;<br><span class="hljs-keyword">if</span> (day === <span class="hljs-number">0</span>) &#123;<br>    day_zh = <span class="hljs-string">&#x27;1号&#x27;</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (day === <span class="hljs-number">1</span>) &#123;<br>    day_zh = <span class="hljs-string">&#x27;2号&#x27;</span><br>&#125;<br>...<br><span class="hljs-keyword">else</span> &#123;<br>    day_zh = <span class="hljs-string">&#x27;31号&#x27;</span><br>&#125;;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>  day_zh = <span class="hljs-string">&#x27;1号&#x27;</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>  day_zh = <span class="hljs-string">&#x27;2号&#x27;</span><br>  <span class="hljs-keyword">break</span>;...<br>&#125;<br><br><span class="hljs-comment">// 把这些数据存到一张表里面，简单方便。</span><br><span class="hljs-keyword">const</span> mouth = [<span class="hljs-string">&#x27;1号&#x27;</span>, <span class="hljs-string">&#x27;2号&#x27;</span>,..., <span class="hljs-string">&#x27;31号&#x27;</span>] <br><span class="hljs-keyword">const</span> day = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>()<br><span class="hljs-keyword">const</span> day_zh = mouth[day]<br></code></pre></td></tr></table></figure></li></ul><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><ul><li>模块化是将一个复杂的程序依据一定的规范封装成几个块&#x2F;文件并进行组合。模块内部数据的实现是私有的，只是向外部暴露一些接口从而可以跟外部其他模块通信。将代码模块化就是将代码分门别类归纳好，同种功能的代码放在一起归置好，待到要使用时再引入这段代码，就不需要重复写相同逻辑的代码了。</li><li>三个模块之间不会相互影响；多个View能共享一个Model，提高代码的可重用性；Controller 是自包含的对象，与 Model 和 View 保持相对独立，可以方便的改变应用程序的数据层和业务规则，从而提高了应用程序的灵活性和可配置性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件与事件委托</title>
    <link href="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h4 id="捕获与冒泡"><a href="#捕获与冒泡" class="headerlink" title="捕获与冒泡"></a>捕获与冒泡</h4><ul><li><p>【事件捕获】：<strong>从外向内</strong>找监听函数（<code>gnYe</code>&gt;<code>fnBa</code>&gt;<code>fnEr</code>）</p></li><li><p>【事件冒泡】：<strong>从内向外</strong>找监听函数（<code>fnEr</code>&gt;<code>fnBa</code>&gt;<code>fnYe</code>）</p></li><li><p><code>W3C</code>规定：（1）浏览器应该同时支持两种调用顺序。有监听函数就调用，并提供事件信息，没有就跳过；（2）首先按从外到内的顺序查看是否有函数监听；（3）然后按从内到外的顺序查看是否有函数监听。【过程是固定的，只是看中间是否有函数监听】</p></li><li><p><strong>【2022年，浏览器都变成了：先捕获再冒泡】</strong></p></li><li><p>【开发者自己选择把<code>fnYe</code>（最外层）放在<u>捕获&#x2F;冒泡</u>阶段】</p></li><li><p>一个函数的捕获与冒泡事件都是要走的，只是取决于你在哪边执行函数</p></li><li><p>捕获与冒泡示意图（3个过程）</p><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/1-%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1.png" class=""></li></ul><h4 id="W3C事件模型"><a href="#W3C事件模型" class="headerlink" title="W3C事件模型"></a><code>W3C</code>事件模型</h4><ul><li><p>事件绑定<code>API</code>：【<code>addEventListener</code>】</p></li><li><p>如何使用：<code>xxx.addEventListener(&#39;click&#39;,fn,bool)</code></p><ul><li><code>bool</code>取值为<code>falsy</code>，就让函数<code>fn</code>走冒泡，即当浏览器在<strong>冒泡阶段</strong>发现某元素有** <code>fn</code>监听函数**，就会调用<code>fn</code>并提供事件信息。</li><li><code>bool</code>取值为<code>true</code>，就让函数<code>fn</code>走捕获，即当浏览器在<strong>捕获阶段</strong>发现某元素有** <code>fn</code>监听函数**，就会调用<code>fn</code>并提供事件信息。</li><li>【注意】：这里的走冒泡&#x2F;捕获不是单走该阶段的，而是捕获冒泡两个事件都会走一遍，只是选择让函数在哪个事件中执行而已；走冒泡就在冒泡阶段执行，走捕获就在捕获阶段执行</li></ul></li><li><p>示意图</p><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/2-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%93%AA%E8%BE%B9%E6%89%A7%E8%A1%8C.png" class=""></li><li><p><a href="http://js.jirengu.com/zirozujedu/1/edit?html,js,output">捕获与冒泡 — 举例</a></p><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/3-%E4%BB%A3%E7%A0%81%E5%9B%BE%E8%A7%A3.png" class=""><p>e（随便给事件对象取的名字）对象被传给所有监听函数，事件结束后，e对象就不存在了</p></li><li><p>【<code>W3C</code>事件模型】：**<u>先捕获，再冒泡</u>**</p><ul><li>子元素被点击了，表示父元素也被点击了</li><li>先调用父元素再调用子元素</li></ul></li></ul><h4 id="target、currentTarget、取消冒泡"><a href="#target、currentTarget、取消冒泡" class="headerlink" title="target、currentTarget、取消冒泡"></a><code>target</code>、<code>currentTarget</code>、取消冒泡</h4><ul><li><code>e.target</code> — 用户操作的元素</li><li><code>e.currentTarget</code> — 程序员监听的元素</li><li><code>this</code> 就是 <code>e.currentTarget</code>（不推荐用）</li><li>举例：<code>div&gt;span</code><ul><li>用户点击文字 &#x3D;》<code>e.target</code>就是<code>span</code></li><li><code>e.currentTarget</code>就是<code>div</code></li></ul></li><li>取消冒泡<ul><li>捕获不能取消，但冒泡可以</li><li>用 【<code>e.stopPropagation()</code>】可以中断冒泡，使浏览器不再往上走</li><li>作用：一般用于封装某些独立的组件</li></ul></li><li>不可阻止默认动作 → 有些事件不能阻止默认动作<ul><li>方法：【<code>x.preventDefalut</code>】</li><li>使用时查看<code>MDN</code>，看该事件能否取消冒泡，例如<code>scroll event</code></li></ul></li></ul><h4 id="阻止滚动"><a href="#阻止滚动" class="headerlink" title="阻止滚动"></a>阻止滚动</h4><ul><li><p><code>scroll</code>事件不可阻止默认动作</p><ul><li><p>【1】阻止<code>scroll</code>默认动作无效，∵ 先有滚动才有滚动事件</p></li><li><p>【2】若要阻止滚动，可以从阻止【滚轮事件<code>wheel</code>】（PC端）和【触屏事件<code>touchstart</code>】（移动端）入手</p></li><li><p>【3】实现阻止滚动时，<strong>需要找准滚动条所在元素进行设置</strong>（是在<code>body</code>、<code>head</code>、<code>document</code>哪个网页元素&#x2F;节点中）【查找方法：打开浏览器控制台，找到<code>Elements</code>后，一个一个标签元素点击比对，看看点到哪个才把滚动条包含在内】</p></li><li><p>【4】虽然阻止了滚动，但滚动条还能用，<strong>此时可以设置<code>CSS</code>让滚动条的 <code>width:0</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//取消滚动条</span><br>::-webkit-scrollbar&#123;<span class="hljs-attr">width</span>:<span class="hljs-number">0</span> !important&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>举例说明 → 【<a href="http://js.jirengu.com/duciqigiva/1/edit?html,css,js,output">阻止滚动</a>】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">x.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  e.<span class="hljs-title function_">preventDefault</span>()<br>&#125;) <span class="hljs-comment">// 阻止PC端滚动</span><br>x.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  e.<span class="hljs-title function_">preventDefault</span>()<br>&#125;) <span class="hljs-comment">// 阻止移动端滚动</span><br></code></pre></td></tr></table></figure><ul><li>使用【<code>overflow:hidden</code>】可直接取消滚动条，不过此时<code>JS</code>仍然可以修改<code>scrollTop</code></li></ul></li><li><p>小结</p><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/4-%E5%B0%8F%E7%BB%93.png" class=""></li></ul><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">浏览器自带事件</a></p></li><li><p>所以：【开发者能否在自带事件外，自定义事件】</p></li><li><p>可以：<a href="http://js.jirengu.com/tuhonowiga/1/edit?html,js,output">举例 — 点击触发XXX事件</a></p></li><li><p>自定义事件：可以自动冒泡，但不能阻止冒泡（取决于自定义的布尔值为true或空）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JS</span><br>button1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;Wilson&#x27;</span>,&#123;<br>        <span class="hljs-attr">detail</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Wilson&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">25</span>&#125;,<br>        <span class="hljs-attr">bubbles</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//自动冒泡</span><br>        <span class="hljs-attr">cancelabel</span>:<span class="hljs-literal">false</span><span class="hljs-comment">//阻止冒泡</span><br>    &#125;)<br>    button1.<span class="hljs-title function_">dispatchEvent</span>(event)<br>&#125;)<br>div1.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Wilson&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Wilson事件触发了&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">detail</span>)<br>&#125;)<br><span class="hljs-comment">//打印结果如下</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Wilson事件触发了 </span><br><span class="hljs-comment">    &#123;name:&quot;Wilson&quot;,age:25&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><ul><li><p>【案例一】现有100个按钮添加点击事件，怎么操作？监听这100个按钮的祖先，等到冒泡的时候再判断target是否为这100个按钮中的其中一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">div1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> t = e.<span class="hljs-property">target</span><br>    <span class="hljs-keyword">if</span>(t.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;button&#x27;</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;button被点击了&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;button data-id 是&#x27;</span>+t.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/5-100%E4%B8%AA%E6%8C%89%E9%92%AE%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6.png" class=""></li><li><p>【案例二】你要监听目前不存在的元素的点击事件，怎么办？监听祖先，等点击的时候看是不是想要监听的元素即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> t = e.<span class="hljs-property">target</span><br>    <span class="hljs-keyword">if</span>(t.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;button&#x27;</span>)&#123; <span class="hljs-comment">//tagName的小写为button</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;button 被 click 了&#x27;</span>)<br>    &#125;    <br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2022/04/10/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/6-%E7%9B%91%E5%90%AC%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6.png" class=""></li><li><p>事件委托的优点：省监听数（内存）；可以监听动态元素</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TEST</title>
    <link href="/2022/04/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/04/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight django"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_path</span> slug %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> slug [title] %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_link</span> slug [title] %&#125;</span><br></code></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#123;<span class="hljs-symbol">%</span> asset_img <span class="hljs-built_in">example</span>.jpg This <span class="hljs-built_in">is</span> an <span class="hljs-built_in">example</span> <span class="hljs-built_in">image</span> <span class="hljs-symbol">%</span>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h5 id="在页面中显示图片-↓"><a href="#在页面中显示图片-↓" class="headerlink" title="在页面中显示图片 ↓"></a>在页面中显示图片 ↓</h5><img src="/2022/04/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="">]]></content>
    
    
    <categories>
      
      <category>TEST</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/10/hello-world/"/>
    <url>/2022/04/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>TEST</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
